package job_build_for_docker

@Library("devops@job_build_for_docker")
import hyperpaint.util.Regex
import hyperpaint.util.Shell
import hyperpaint.util.Util

Shell.setJenkins(this)

/* Получение параметров, проверка и назначение значений по-умолчанию */
/** Выбирать последние версии автоматически */
Boolean useLatestVersion = params.use_latest_version
Boolean useLatestVersionDefault = false
String useLatestVersionDescription = "Выбирать последние версии автоматически"
/** Использовать кэш загрузок */
Boolean useCacheFile = params.use_cache_file
Boolean useCacheFileDefault = true
String useCacheFileDescription = "Использовать кэш загрузок"
/** Использовать кэш сборок */
Boolean useCacheDocker = params.use_cache_docker
Boolean useCacheDockerDefault = true
String useCacheDockerDescription = "Использовать кэш сборок"
/** Деплой и проверка состояния контейнера */
Boolean deployImage = params.deploy_image
Boolean deployImageDefault = true
String deployImageDescription = "Деплой и проверка состояния контейнера"
/** Экспортировать образ */
Boolean exportImage = params.export_image
Boolean exportImageDefault = false
String exportImageDescription = "Экспортировать образ"
/** Удалить образ */
Boolean deleteImage = params.delete_image
Boolean deleteImageDefault = false
String deleteImageDescription = "Удалить образ"

/* Получение переменных окружения */
String hostCredentials = env.host_credentials
String sshCredentials = env.ssh_credentials
String dockerComposeProjectDirectory = env.docker_compose_project_directory

/** Docker image name */
String imageName = env.image_name

/** URL на страницу с релизами или дистрибутив */
String appUrl = env.app_url
/** Инвертировать список ссылок */
Boolean appUrlReverse = env.app_url_reverse.toBoolean()
/** Количество регулярных выражений для отбора ссылок */
Integer appDistributiveUrlRegexCount = env.app_distributive_url_regex_count.toInteger()

String themesDirectory = env.themes_directory
/** Количество плагинов */
Integer themesCount = env.themes_count.toInteger()
/** Инвертировать список ссылок */
Boolean themeUrlReverse = env.theme_url_reverse.toBoolean()
/** Количество регулярных выражений для отбора ссылок */
Integer themeDistributiveUrlRegexCount = env.theme_distributive_url_regex_count

String pluginsDirectory = env.plugins_directory
/** Количество плагинов */
Integer pluginsCount = env.plugins_count.toInteger()
/** Инвертировать список ссылок */
Boolean pluginUrlReverse = env.plugin_url_reverse.toBoolean()
/** Количество регулярных выражений для отбора ссылок */
Integer pluginDistributiveUrlRegexCount = env.plugin_distributive_url_regex_count

/* Константы */
int cacheLifetime = 86400
String buildDirectory = "build-directory"

/* Функции */

/**
 * Скачать страницу с релизами. Найти на ней все ссылки.
 * Преобразовать относительные ссылки в абсолютные.
 * Отобрать среди них те, что подходят по регулярным выражениям и уникальные.
 * При необходимости инвертировать список ссылок.
 * Если ссылок несколько, то запросить ввод, выбрать дистрибутив, скачать его и распаковать.
 * @param artifactFileName Название файла артефакта
 * @param url URL на страницу с релизами или дистрибутив
 * @param regexArray Массив регулярных выражений для отбора ссылок
 * @param urlReverse Инвертировать список ссылок
 * @param destination Директория, в которую распаковать дистрибутив
 */
void releasesPage(String artifactFileName, String url, String[] regexArray, Boolean urlReverse, String destination) {
    String releasesHtmlFileName
    if (artifactFileName == null) releasesHtmlFileName = "releases.html" else releasesHtmlFileName = "releases-${artifactFileName}.html"
    if (useCacheFile) Util.downloadFile(url, releasesHtmlFileName, cacheLifetime) else Util.downloadFile(url, releasesHtmlFileName, -1)

    /* Найти на странице с релизами все ссылки href с тегом <a> */
    String releasesHtml = readFile(releasesHtmlFileName)
    List<String> urlsList = Regex.groupAll(releasesHtml, "<a[A-Za-z0-9\\-_\\.\\s]*href\\s*=\\s*\"([A-Za-z0-9\\-_\\.]+)\"[A-Za-z0-9\\-_\\.\\s]*>")

    /* Преобразование относительных ссылок в абсолютные */
    Shell.echo("Преобразовываю относительные ссылки в абсолютные")
    List<String> absoluteUrlsList = new ArrayList<>()
    for (int i = 0; i < urlsList.size(); i++) {
        String currentUrl = urlsList.get(i)
        if (Regex.find(currentUrl, "^(\\.\\/){0,1}[A-Za-z0-9\\-_\\.]+[\\/]{0,1}\$")) {
            /* Относительная ссылка */
            absoluteUrlsList.add(url + currentUrl)
        } else {
            /* Абсолютная ссылка */
            absoluteUrlsList.add(currentUrl)
        }
    }

    /* Отобрать только те ссылки, которые подходят по регулярному выражению */
    Shell.echo("Отбираю ссылки, которые подходят по регулярному выражению")
    urlsList.clear()
    for (int i = 0; i < absoluteUrlsList.size(); i++) {
        String currentUrl = absoluteUrlsList.get(i)

        Boolean success = true
        for (int regex = 0; regex < regexArray.size(); regex++) {
            if (!Regex.find(currentUrl, regexArray[regex])) {
                success = false
                break
            }
        }

        if (success) {
            // Подходящая ссылка
            if (!urlsList.contains(currentUrl)) {
                // Уникальная ссылка
                urlsList.add(currentUrl)
            }
        }
    }

    /* Инвертирование списка */
    if (urlReverse) {
        Shell.echo("Инвертирую список")
        urlsList = urlsList.reverse()
    }

    /* Если ссылок несколько, то запросить ввод */
    String downloadUrl = null
    if (urlsList.size() == 0) {
        Shell.error("Найдено ${urlsList.size()} ссылок")
    } else {
        Shell.echo("Найдено ${urlsList.size()} ссылок")
        if (urlsList.size() == 1) {
            downloadUrl = urlsList.get(0)
        } else {
            if (useLatestVersion) {
                downloadUrl = urlsList.get(0)
            } else {
                downloadUrl = input(message: "Выбор версии ${url}", parameters: [choice(name: "Версия", choices: urlsList.join('\n'))]).toString()
            }
        }
    }

    /* Скачать дистрибутив */
    String fileName = Regex.group(downloadUrl, ".+\\/(.+)(\\/){0,1}(?.*){0,1}\$")
    if (useCacheFile) Util.downloadFile(downloadUrl, fileName) else Util.downloadFile(downloadUrl, fileName, -1)
    Util.unarchiveFile(fileName, destination, true)
}

/**
 * Скачать дистрибутив и распаковать.
 * @param isArtifactFileNameDefined Название файла артефакта задано
 * @param url URL на страницу с релизами или дистрибутив
 * @param destination Директория, в которую распаковать дистрибутив
 */
void distributive(Boolean isArtifactFileNameDefined, String url, String destination) {
    /* Скачать дистрибутив */
    String downloadUrl = url
    String fileName
    if (isArtifactFileNameDefined) {
        fileName = Regex.group(downloadUrl, "[\\?\\&]artifact_file_name=([A-Za-z0-9\\-_\\.])")
    } else {
        fileName = Regex.group(downloadUrl, ".+\\/(.+)(\\/){0,1}(?.*){0,1}\$")
    }
    if (useCacheFile) Util.downloadFile(downloadUrl, fileName) else Util.downloadFile(downloadUrl, fileName, -1)
    Util.unarchiveFile(fileName, destination, true)
}

pipeline {
    agent any
    parameters {
        booleanParam(name: "use_latest_version", defaultValue: useLatestVersionDefault, description: useLatestVersionDescription)
        booleanParam(name: "use_cache_file", defaultValue: useCacheFileDefault, description: useCacheFileDescription)
        booleanParam(name: "use_cache_docker", defaultValue: useCacheDockerDefault, description: useCacheDockerDescription)
        booleanParam(name: "deploy_image", defaultValue: deployImageDefault, description: deployImageDescription)
        booleanParam(name: "export_image", defaultValue: exportImageDefault, description: exportImageDescription)
        booleanParam(name: "delete_image", defaultValue: deleteImageDefault, description: deleteImageDescription)
    }
    options {
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '10'))
    }
    stages {
        stage("Параметры и переменные окружения") {
            steps {
                script {
                    /* Задание стандартных параметров */
                    String notFoundParamStringSetDefault = "Параметр '%s' не найден, использую стандартное значение '%s'"
                    String foundParamString = "Параметр '%s' найден"

                    if (useLatestVersion == null) {
                        useLatestVersion = true
                        Shell.echo(String.format(notFoundParamStringSetDefault, "use_latest_version", useLatestVersion.toString()))
                    } else {
                        Shell.echo(String.format(foundParamString, "use_latest_version"))
                    }

                    if (useCacheFile == null) {
                        useCacheFile = true
                        Shell.echo(String.format(notFoundParamStringSetDefault, "use_cache_file", useCacheFile.toString()))
                    } else {
                        Shell.echo(String.format(foundParamString, "use_cache_file"))
                    }

                    if (useCacheDocker == null) {
                        useCacheDocker = true
                        Shell.echo(String.format(notFoundParamStringSetDefault, "use_cache_docker", useCacheDocker.toString()))
                    } else {
                        Shell.echo(String.format(foundParamString, "use_cache_docker"))
                    }

                    if (deployImage == null) {
                        deployImage = true
                        Shell.echo(String.format(notFoundParamStringSetDefault, "deploy_image", deployImage.toString()))
                    } else {
                        Shell.echo(String.format(foundParamString, "deploy_image"))
                    }

                    if (exportImage == null) {
                        exportImage = true
                        Shell.echo(String.format(notFoundParamStringSetDefault, "export_image", exportImage.toString()))
                    } else {
                        Shell.echo(String.format(foundParamString, "export_image"))
                    }

                    if (deleteImage == null) {
                        deleteImage = true
                        Shell.echo(String.format(notFoundParamStringSetDefault, "delete_image", deleteImage.toString()))
                    } else {
                        Shell.echo(String.format(foundParamString, "delete_image"))
                    }

                    /* Проверка переменных окружения */
                    /* Проверка необязательных переменных окружения */
                    String notFoundEnvStringSetDefault = "Переменная окружения '%s' не найдена, использую стандартное значение '%s'"
                    /* Проверка обязательных переменных окружения */
                    String notFoundEnvStringError = "Переменная окружения '%s' не найдена, выполнение невозможно"
                    String foundEnvString = "Переменная окружения '%s' найдена"

                    if (hostCredentials == null) {
                        Shell.error(String.format(notFoundEnvStringError, "host_credentials"))
                    } else {
                        Shell.echo(String.format(foundEnvString, "host_credentials"))
                    }

                    if (sshCredentials == null) {
                        Shell.error(String.format(notFoundEnvStringError, "ssh_credentials"))
                    } else {
                        Shell.echo(String.format(foundEnvString, "ssh_credentials"))
                    }

                    if (dockerComposeProjectDirectory == null) {
                        Shell.error(String.format(notFoundEnvStringError, "docker_compose_project_directory"))
                    } else {
                        Shell.echo(String.format(foundEnvString, "docker_compose_project_directory"))
                    }

                    if (imageName == null) {
                        Shell.error(String.format(notFoundEnvStringError, "image_name"))
                    } else {
                        Shell.echo(String.format(foundEnvString, "image_name"))
                    }

                    if (appUrl == null) {
                        Shell.error(String.format(notFoundEnvStringError, "app_url"))
                    } else {
                        Shell.echo(String.format(foundEnvString, "app_url"))
                    }

                    if (appUrlReverse == null) {
                        appUrlReverse = false
                        Shell.echo(String.format(notFoundEnvStringSetDefault, "app_url_reverse", appUrlReverse))
                    } else {
                        Shell.echo(String.format(foundEnvString, "app_url_reverse"))
                    }

                    if (appDistributiveUrlRegexCount == null) {
                        appDistributiveUrlRegexCount = 0
                        Shell.echo(String.format(notFoundEnvStringSetDefault, "app_distributive_url_regex_count", appDistributiveUrlRegexCount))
                    } else {
                        Shell.echo(String.format(foundEnvString, "app_distributive_url_regex_count"))
                        if (appDistributiveUrlRegexCount != 0) {
                            for (int i = 1; i <= appDistributiveUrlRegexCount; i++) {
                                if (env["app_distributive_url_regex${i}"] == null) {
                                    Shell.error(String.format(notFoundEnvStringError, "app_distributive_url_regex${i}"))
                                } else {
                                    Shell.echo(String.format(foundEnvString, "app_distributive_url_regex${i}"))
                                }
                            }
                        }
                    }

                    if (themesCount == null) {
                        themesCount = 0
                        Shell.echo(String.format(notFoundEnvStringSetDefault, "themes_count", themesCount.toString()))
                    } else {
                        Shell.echo(String.format(foundEnvString, "themes_count"))
                        if (themesCount != 0) {
                            if (themesDirectory == null) {
                                Shell.error(String.format(notFoundEnvStringError, "themes_directory"))
                            } else {
                                Shell.echo(String.format(foundEnvString, "themes_directory"))
                            }

                            for (int i = 1; i <= themesCount; i++) {
                                if (env["theme_url${i}"] == null) {
                                    Shell.error(String.format(notFoundEnvStringError, "theme_url${i}"))
                                } else {
                                    Shell.echo(String.format(foundEnvString, "theme_url${i}"))
                                }
                            }

                            if (themeUrlReverse == null) {
                                themeUrlReverse = false
                                Shell.echo(String.format(notFoundEnvStringSetDefault, "theme_url_reverse", themeUrlReverse))
                            } else {
                                Shell.echo(String.format(foundEnvString, "theme_url_reverse"))
                            }

                            if (themeDistributiveUrlRegexCount == null) {
                                themeDistributiveUrlRegexCount = 0
                                Shell.echo(String.format(notFoundEnvStringSetDefault, "theme_distributive_url_regex_count", themeDistributiveUrlRegexCount))
                            } else {
                                Shell.echo(String.format(foundEnvString, "theme_distributive_url_regex_count"))
                                if (themeDistributiveUrlRegexCount != 0) {
                                    for (int i = 1; i <= themeDistributiveUrlRegexCount; i++) {
                                        if (env["theme_distributive_url_regex${i}"] == null) {
                                            Shell.error(String.format(notFoundEnvStringError, "theme_distributive_url_regex${i}"))
                                        } else {
                                            Shell.echo(String.format(foundEnvString, "theme_distributive_url_regex${i}"))
                                        }
                                    }
                                }
                            }
                        }
                    }

                    if (pluginsCount == null) {
                        pluginsCount = 0
                        Shell.echo(String.format(notFoundEnvStringSetDefault, "plugins_count", pluginsCount.toString()))
                    } else {
                        Shell.echo(String.format(foundEnvString, "plugins_count"))
                        if (pluginsCount != 0) {
                            if (pluginsDirectory == null) {
                                Shell.error(String.format(notFoundEnvStringError, "plugins_directory"))
                            } else {
                                Shell.echo(String.format(foundEnvString, "plugins_directory"))
                            }

                            for (int i = 1; i <= pluginsCount; i++) {
                                if (env["plugin_url${i}"] == null) {
                                    Shell.error(String.format(notFoundEnvStringError, "plugin_url${i}"))
                                } else {
                                    Shell.echo(String.format(foundEnvString, "plugin_url${i}"))
                                }
                            }

                            if (pluginUrlReverse == null) {
                                pluginUrlReverse = false
                                Shell.echo(String.format(notFoundEnvStringSetDefault, "plugin_url_reverse", pluginUrlReverse))
                            } else {
                                Shell.echo(String.format(foundEnvString, "plugin_url_reverse"))
                            }

                            if (pluginDistributiveUrlRegexCount == null) {
                                pluginDistributiveUrlRegexCount = 0
                                Shell.echo(String.format(notFoundEnvStringSetDefault, "plugin_distributive_url_regex_count", pluginDistributiveUrlRegexCount))
                            } else {
                                Shell.echo(String.format(foundEnvString, "plugin_distributive_url_regex_count"))
                                if (pluginDistributiveUrlRegexCount != 0) {
                                    for (int i = 1; i <= pluginDistributiveUrlRegexCount; i++) {
                                        if (env["plugin_distributive_url_regex${i}"] == null) {
                                            Shell.error(String.format(notFoundEnvStringError, "plugin_distributive_url_regex${i}"))
                                        } else {
                                            Shell.echo(String.format(foundEnvString, "plugin_distributive_url_regex${i}"))
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        stage("Получаю дистрибутив") {
            steps {
                script {
                    /* Распарсить параметры из ссылки */
                    Boolean isArtifactFileNameDefined = Regex.find(appUrl, "[\\?\\&]artifact_file_name=([A-Za-z0-9\\-_\\.])")
                    Boolean isReleasesPage = Regex.find(appUrl, "[\\?\\&]is_releases_page=1")
                    if (isReleasesPage) {
                        if (isArtifactFileNameDefined) {
                            Shell.echo("${appUrl} - Страница HTML с ссылками с именем артефакта")
                        } else {
                            Shell.echo("${appUrl} - Страница HTML с ссылками")
                        }
                    }
                    Boolean isDistributive = Regex.find(appUrl, "[\\?\\&]is_distributive=1")
                    if (isDistributive && !isReleasesPage) {
                        if (isArtifactFileNameDefined) {
                            Shell.echo("${appUrl} - Архив дистрибутива с именем артефакта")
                        } else {
                            Shell.echo("${appUrl} - Архив дистрибутива")
                        }
                    }

                    Runnable releasesPageRunnable = {
                        //String artifactFileName = Regex.group(appUrl, "[\\?\\&]artifact_file_name=([A-Za-z0-9\\-_\\.])")
                        String[] regexArray = new String[appDistributiveUrlRegexCount]
                        for (int i = 0; i < appDistributiveUrlRegexCount; i++) {
                            regexArray[i] = env["app_distributive_url_regex${i+1}"]
                        }
                        releasesPage(null, appUrl, regexArray, appUrlReverse, buildDirectory)
                    }

                    if (isReleasesPage) {
                        releasesPageRunnable.run()
                    } else if (isDistributive) {
                        distributive(isArtifactFileNameDefined, appUrl, buildDirectory)
                    } else {
                        releasesPageRunnable.run()
                    }
                }
            }
        }
    }
}